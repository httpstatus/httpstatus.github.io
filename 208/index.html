<!DOCTYPE html>
<html lang="en">
  <head>
    <title>208 Already Reported &mdash; httpstatus.github.io</title>
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="/style.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta charset="utf-8">
    <meta name="description" content="HTTP Status Code 208: Used inside a DAV: propstat response element to avoid enumerating the internal members of multiple bindings to the same collection repeatedly.">
  </head>
  <body>
    <div class="banner">
      <div class="container">
        <div class="row">
          <div class="twelve columns">
            <p><a class="returnlink" href="/">&larr; Return to httpstatus.github.io</a></p>
          </div>
        </div>
      </div>
    </div>
    <article class="code container">
      <h2>2&times;&times; Success</h2>
      <h1><span>208</span> Already Reported</h1><p>Used inside a DAV: propstat response element to avoid enumerating the internal members of multiple bindings to the same collection repeatedly.</p>
<p>For each binding to a collection inside the request&#39;s scope, only one will be reported with a 200 status, while subsequent DAV:response elements for all other bindings will use the 208 status, and no DAV:response elements for their descendants are included.</p>
<p>Note that the 208 status will only occur for &quot;Depth: infinity&quot; requests, and that it is of particular importance when the multiple collection bindings cause a bind loop<sup><a href="#ref-1">1</a></sup>.</p>
<p>A client can request the DAV:resource-id property in a PROPFIND request to guarantee that they can accurately reconstruct the binding structure of a collection with multiple bindings to a single resource.</p>
<p>For backward compatibility with clients not aware of the 208 status code appearing in multistatus response bodies, it SHOULD NOT be used unless the client has signaled support for this specification using the &quot;DAV&quot; request header<sup><a href="#ref-2">2</a></sup>. Instead, a <a href="/508">508 Loop Detected</a> status should be returned when a binding loop is discovered. This allows the server to return the 508 as the top-level return status, if it discovers it before it started the response, or in the middle of a multistatus, if it discovers it in the middle of streaming out a multistatus response.</p>
<hr>
<ul>
<li><span id="ref-1"><sup>1</sup> URI Mappings Created by a New Binding
<a href="https://tools.ietf.org/html/rfc5842#section-2.2">RFC5842 Section 2.2</a></span></li>
<li><span id="ref-2"><sup>2</sup> &#39;DAV&#39; Request Header
<a href="https://tools.ietf.org/html/rfc5842#section-8.2">RFC5842 Section 8.2</a></span></li>
<li>Source: <a href="https://tools.ietf.org/html/rfc5842#section-7.1">RFC5842 Section 7.1</a></li>
</ul>

      <h1 class="section"><span>208</span> Code References</h1>
      <p>Symfony HTTP Status Constant <code>Response::HTTP_ALREADY_REPORTED</code></p><a class="returnlink" href="/">&larr; Return to httpstatus.github.io</a>
    </article>



<hr><center><div width=222px height=333px ><h3>by the foundation</h3>
<a href="https://the-foundation.gitlab.io/"><div><img src="https://hcxi2.2ix.ch/gitlab/the-foundation/docker-cache-nuster/README.md/logo.jpg" width="480" height="270"/></div></a>
<div></center>
  </body> <script type="application/javascript" >
function getLocation(href) {
    var match = href.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)([\/]{0,1}[^?#]*)(\?[^#]*|)(#.*|)$/);
    return match && {
        href: href,
        protocol: match[1],
        host: match[2],
        hostname: match[3],
        port: match[4],
        pathname: match[5],
        search: match[6],
        hash: match[7]
    }
}
if(document.referrer != "" ) { 
                console.log("found referrer: "+document.referrer)var links = document.getElementsByClassName("returnlink");
                for(var i=0; i<links.length; i++)
                {
                    //console.log(links[i].innerHTML);
                    //console.log(links[i].href);
                    links[i].innerHTML="← Return to "+document.referrer;
                    var parsedURL=getLocation(document.referrer);
                    console.log("setting returnlinks to "+parsedURL.protocol+'//'+parsedURL.host );links[i].href=parsedURL.protocol+'//'+parsedURL.host ;
                }
                
}
</script>
</html>
